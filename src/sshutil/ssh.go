package sshutil

import (
	"bufio"
	"errors"
	"os"
	"strconv"
	"strings"
)

const (
	DEFAULT_SSH_PORT    = 22
	KNOWN_HOSTS_COMMENT = "Added by oinit"
	CONFIG_COMMENT      = `# This 'Match' block was added by oinit.
#
# Please make sure it stays positioned on top of your ssh config
# file, assuring it will be applied before other 'Host' or 'Match'
# blocks that may interfere with oinit.`
)

// GenerateKnownHosts returns a string that can be added to the user or system
// known_hosts file. The returned string does not end with a line break.
func GenerateKnownHosts(host, port, pubkey string) (string, error) {
	var combinedHost string

	if port == strconv.Itoa(DEFAULT_SSH_PORT) {
		combinedHost = host
	} else {
		// Enclose host within brackets for non-standard port as required by OpenSSH.
		// From sshd(8):
		//   A hostname or address may optionally be enclosed within ‘[’ and ‘]’ brackets then followed by ‘:’ and a
		//   non-standard port number.
		combinedHost = "[" + host + "]:" + port
	}

	// Strip comment from pubkey if present
	parts := strings.Split(pubkey, " ")
	if len(parts) != 2 && len(parts) != 3 {
		return "", errors.New("invalid pubkey format")
	}

	return "@cert-authority " + combinedHost + " " + strings.Join(parts[0:2], " "), nil
}

// AddSSHKnownHost adds a "@cert-authority <hostport> <pubkey>" to the users
// known_hosts file if not already present there or system wide.
func AddSSHKnownHost(host, port, pubkey string) error {
	paths, err := pathsSSHKnownHosts()
	if err != nil {
		return err
	}

	add, err := GenerateKnownHosts(host, port, pubkey)
	if err != nil {
		return err
	}

	for _, path := range []string{paths.System, paths.User} {
		f, err := os.Open(path)
		if err != nil {
			continue
		}
		defer f.Close()

		scanner := bufio.NewScanner(f)
		for scanner.Scan() {
			if strings.HasPrefix(scanner.Text(), add) {
				return nil
			}
		}
	}

	f, err := os.OpenFile(paths.User, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
	if err != nil {
		return err
	}

	if _, err = f.Write([]byte(add + " " + KNOWN_HOSTS_COMMENT + "\n")); err != nil {
		f.Close()
		return err
	}

	f.Close()

	return nil
}

func GenerateMatchBlock() string {
	return "Match exec \"oinit match %h %p\"\n\tUser service"
}

// AddSSHMatchBlock adds the string generated by GenerateMatchBlock() to the
// user's ssh config file, if not already present there or system-wide.
// Returns boolean that indicates whether the match block was added or not.
func AddSSHMatchBlock() (bool, error) {
	paths, err := pathsSSHConfig()
	if err != nil {
		return false, err
	}

	// Search for occurence of 'Match exec ...'
	block := GenerateMatchBlock()
	search := strings.Split(block, "\n")[0]

	for _, path := range []string{paths.System, paths.User} {
		f, err := os.Open(path)
		if err != nil {
			continue
		}
		defer f.Close()

		scanner := bufio.NewScanner(f)
		for scanner.Scan() {
			if scanner.Text() == search {
				return false, nil
			}
		}
	}

	// Prepend match block to user's ssh config file by reading the existing
	// content, prepending the string and writing to file using truncate.

	content, err := os.ReadFile(paths.User)
	if err != nil {
		return false, err
	}

	newContent := []byte(CONFIG_COMMENT + "\n" + block + "\n\n")
	newContent = append(newContent, content...)

	if err := os.WriteFile(paths.User, newContent, 0644); err != nil {
		return false, err
	}

	return true, err
}
